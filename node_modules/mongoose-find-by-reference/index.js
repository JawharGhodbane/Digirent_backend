var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// index.ts
var mongoose_find_by_reference_exports = {};
__export(mongoose_find_by_reference_exports, {
  MongooseFindByReference: () => MongooseFindByReference
});
function MongooseFindByReference(schema) {
  if (schema.constructor.name !== "Schema")
    throw new Error('\u53C2\u6570 "schema" \u7684\u7C7B\u578B\u5F97\u662F "Schema"\u3002\n param "schema" type must be "Schema".');
  schema.pre(["find", "findOne"], async function(next) {
    const models = this.model.db.models;
    if (!models || Object.keys(models).length === 0)
      throw new Error("\u8BBF\u95EE\u5230\u7684 Model \u6570\u91CF\u4E3A 0 \u6216\u8005\u4E0D\u5B58\u5728\u3002\n The number of models accessed is 0 or does not exist.");
    const getRefModel = (obj) => {
      var _a, _b, _c, _d;
      let refKey = "";
      if (obj) {
        if (obj.instance === "ObjectID") {
          if ((_b = (_a = obj.options) == null ? void 0 : _a.ref) == null ? void 0 : _b.length)
            refKey = obj.options.ref;
          else if ((_d = (_c = obj.options) == null ? void 0 : _c.refPath) == null ? void 0 : _d.length) {
            if (schema2.path(obj.options.refPath))
              return { refPath: obj.options.refPath };
          }
        } else if (obj == null ? void 0 : obj.$embeddedSchemaType) {
          return getRefModel(obj.$embeddedSchemaType);
        }
      }
      if (refKey)
        return Object.keys(models).includes(refKey) && models[refKey] || void 0;
    };
    const schema2 = this.model.schema;
    const loopUpdateCoditions = async (prevPaths, conditions, cSchema = schema2) => {
      if (typeof conditions !== "object" || conditions === null || Object.keys(conditions).length === 0)
        return conditions;
      const result = {};
      const prevPathsValue = cSchema.path(prevPaths.join("."));
      for (let [paths, value] of Object.entries(conditions)) {
        if (paths.includes("."))
          [[paths, value]] = Object.entries([...paths.split("."), value].reduceRight((previousValue, currentValue) => currentValue === "$" ? previousValue : { [currentValue]: previousValue }));
        const currentPathsArray = paths.startsWith("$") ? paths === "$" ? prevPaths : [] : [...prevPaths, paths];
        const currentPathsString = currentPathsArray.join(".");
        const currentPathsValue = cSchema.path(currentPathsString);
        if (!paths.startsWith("$")) {
          if (currentPathsValue === void 0) {
            const currentModel = getRefModel(prevPathsValue);
            if (currentModel) {
              if ("refPath" in currentModel) {
                console.error(`Can't do it with 'refPath' because we can't read it in Query.`);
                return void 0;
              } else {
                const subCoditions = await loopUpdateCoditions([], value, currentModel.schema);
                if (subCoditions) {
                  const ids = (await currentModel.find({ [paths]: subCoditions }, "_id")).map((v) => v._id);
                  return { $in: ids };
                }
              }
            }
          }
        }
        if (Array.isArray(value))
          Object.assign(result, {
            [paths]: await Promise.all(value.map(async (v) => await loopUpdateCoditions(currentPathsArray, v, cSchema)))
          });
        else if (typeof value === "object" && value !== null && Object.keys(value).length > 0)
          Object.assign(result, {
            [paths]: Object.fromEntries(await Promise.all(Object.entries(value).map(async ([k, v]) => Object.entries(await loopUpdateCoditions(currentPathsArray, {
              [k]: v
            }, cSchema))[0])))
          });
        else
          result[paths] = value;
      }
      return result;
    };
    this._conditions = await loopUpdateCoditions([], this._conditions);
    next();
  });
}
module.exports = __toCommonJS(mongoose_find_by_reference_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MongooseFindByReference
});
